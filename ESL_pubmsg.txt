	process_options 	本地测试使用

	init_main_context	初始化	
		开辟 mainContext 内存，ble_map对应的gpio操作命令 /etc/init.d/ble39、40、45  start、stop、restart

	get_gateway_mac		获取网关MAC地址

	init_proto_context	初始化
		开辟 protoContext protoCtx->databuf 内存
		init_leds_context		初始化led上下文 打开ws2812-draiveris设备
		init_mqtt_context		初始化mqtt上下文
		init_http_context		初始化http上下文
		init_compress_context	初始化压缩上下文 LZO压缩算法
		init_cmdstate_context	初始化命令状态上下文(cmdStateContext *cmdStateCtx:{struct cds_lfht *cmdCnnStateHT、*cmdScanStateHT 、*bleDataHT})
			cmdStateCtx->cmdScanStateHT = cds_lfht_new(16, 1, 0, CDS_LFHT_AUTO_RESIZE | CDS_LFHT_ACCOUNTING, NULL);
			cmdStateCtx->cmdCnnStateHT = cds_lfht_new(16, 1, 0, CDS_LFHT_AUTO_RESIZE | CDS_LFHT_ACCOUNTING, NULL);
			cmdStateCtx->bleDataHT = cds_lfht_new(16, 1, 0, CDS_LFHT_AUTO_RESIZE | CDS_LFHT_ACCOUNTING, NULL);
			cds_lfht_new 函数分配一个新的哈希表并返回指向它的指针.可在在初始化RCU之前,调用cds_lfht_new
			struct cds_lfht *cds_lfht_new(unsigned long init_size,unsigned long min_nr_alloc_buckets,unsigned long max_nr_buckets,int flags,pthread_attr_t *attr)
		reload_uci
		init_cmdlist_context(cmdListContext *cmdListCtx{struct cds_list_head cmdListHead、current_left_cnt(醒来未被连接的BLE)、auto_release_limit、inWaking}):初始化cmd链表上下文
			CDS_INIT_LIST_HEAD(cmdListCtx *cmdListHead)；
			CDS_INIT_LIST_HEAD (ptr):初始化一个cds_list_hea
		attach_gpio_to_uart		gpio与uart关联
			load_usb_devices 获取usb设备以及usb个数保存在 mainCtx->usbDevices、mainCtx->uartNum
			init_uart_context(3次) 每次初始化一个uart设置相关参数，创建3个线程。共计9个线程
	--->		uart_poll_thread	从uart读取数据写入到队列中	打印非扫描状态的 BLE 模块的数据
				
	--->		uart_rsp_thread		从队列中读取数据，没有则打印 uartNo:x,len<0: -1
					dispatch_rsp_result		 		处理响应结果
						check_rsp_format			检查响应数据格式是否正确
						get_rsp_parameter			获取响应参数
						handle_scan_rsp_status		处理扫描响应状态
							。。。。			如果是初始化就 handle_init_rsp_status ，否则就 handle_normal_rsp_status 处理正常响应状态
						release_uart_status			释放uart状态
						handle_data_domain			处理扫描广告包，根据 function lists 中不同的function
							handle_ble_data			将ble数据封装为json 
								update_ble_data		更新BLE设备信息到 cmdStateContext 表中，通过 mac 与seed 找到hash值，然后用 rcu系列函数 从 cmdStateCtx.bleDataHT 提取 iter ，然后找到 对应的节点
									search_scan_state_to_update	 		对第一次接收到广播包的数据进行记录  修改最近一次收到该广播包的时间戳 并更新 该设备被唤醒的状态 以及记录唤醒未被连的数目，打印被唤醒 记录时间点
								write_to_mempool	写入到 memPoolCtx 内存池中，附加BLE no信息
				
	--->		uart_ctrl_thread	通过uart发送控制命令信息到BLE模块，BLE-->ESL
					add_scan_all_time_to_list 		初始化 CmdSubListHeadNode， 并添加scan 命令到链表中
						product_ScanStart_cmd		序列化扫描启动命令，NEW_SUB_LIST_NODE、INIT_SUB_LIST_NODE、INIT_EXT_MDU、INIT_FIXED_HEADER、PRINT_CMD_DATA
							add_cmd_to_sub_list		添加scan start cmd节点到双链表 sub_list_head 的尾部-
						product_ScanStop_cmd		序列化扫描停止命令，NEW_SUB_LIST_NODE、INIT_SUB_LIST_NODE、INIT_EXT_MDU、INIT_FIXED_HEADER、PRINT_CMD_DATA
							add_cmd_to_sub_list		添加scan stop  cmd节点到双链表 sub_list_head 的尾部
						设置用于扫描模块的属性(uart2) 并且打印：Central {BLE%d:UART%d} start to used as scanning
					while							进入大循环
						get_sub_list				从命令链表 cmdListConext 里获取 cmdSubList 子链表				
						。。。。。。。。。待续
			choose_ble_gpio				设置uart 与 对应的 GPIO并启动 。    wake_uart_no0、cnn_uart_no1、scan_uart_no2
			set_ble_scan_number			设置用于扫描模块的数量		
										打印每个模块分工 wake:->BLE:0,scan:->BLE:2,cnn:->BLE:1
			get_ble_version				打印模块最小版本号
				utils_version_to_string	将BLE版本从uint32_t转换为字符串格式


	stop_init			初始化退出条件：各种信号

--->handle_leds_thread		ws2812 led线程
		。。。。
	connect_mqtt_server		mqtt连接

	SET_STATE				设置网络状态
	
	return_init_code		网关版本号、型号、BLE版本号、初始化成功的BLE模块等等信息 加上SFixedHeader 通过mqtt发送到服务器


--->neural_center_thread	神经中枢线程
		while 				大循环
			delete_success_state_and_list			删除成功状态和列表
				cds_lfht_for_each_entry{scan_node}	遍历每一个 scan_node 跳过扫描状态阶段不成功的





		